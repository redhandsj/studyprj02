//==========================================================================================================
// Spring徹底入門SpringFrameworkによるJavaアプリケーション開発.pdf
//==========================================================================================================
 - (CHAPTER 05) Webアプリケーションの開発(P.203 - 307)
しおり　：　P.260 ～ 5.8 画面遷移 ～
URL　:
http://localhost:8080/SpringWebApplication01/

★ 2016/11/27(日)に、SpringWebApplication01の勉強の為にSpringThymeleaf01から派生して作成


//==========================================================================================================
// 後で整形
//==========================================================================================================
★ Springには大きく分けて２種類の機能がある
 - 画面応答アプリケーション
 - データのみ応答するアプリケーション

★ サーブレットコンテナの設定
 - ContextLoaderListener
   - @Configuration 付きのクラスを作成する

 - DispatcherServlet
   - はクライアントからのリクエストを受け付ける
   - @Configuration 付きのクラスを作成する
   - @EnableWebMvc
   - @ComponentScan("example.app") 

 - CharacterEncodingFilter
   - setCharacterEncoding("UTF-8");

★ 本格的なアプリケーションコンテキスト
 - MessageSource
   - メッセージ取得用
 - PropertySourcesPlaceholderConfigurer
   - プロパティ値（JVMのシステムプロパティ、環境変数、プロパティファイルに定義した値）をDIコンテナで管理し
     ているコンポーネントにインジェクションするためのコンポーネント

★ Controllerで実装する処理の全体像
 - メソッドシグネチャを参照してフロントコントローラが処理を行なう「宣言型」の処理
   - リクエストマッピング
   - リクエストデータの取得
   - 入力チェックの実行
 - Controllerクラスのメソッド内に処理を実装する「プログラミング型」の処理
   - 入力チェック結果のハンドリング
   - ビジネスロジックの呼び出し
   - 遷移先とのデータ連携
   - 遷移先の指定

★ Controllerクラスの作成
 - POJOで作成
 - POJOクラスに@Controllerを指定することで、以下の効果を得られます。
   - コンポーネントスキャン機能を使用してDIコンテナにBean登録可能
   - リクエストをハンドリングするメソッド（以降、Handlerメソッドと呼ぶ）が定義されているクラスとして認識
 - value属性を省略した場合はSpringが定めた命名規約に則ったBean IDが適用
   - クラス名「WelcomeController」→ 「welcomeController」
 - コンポーネントスキャン機能を使ってDIコンテナに登録

★ Handleメソッドの引数
 - Spring MVCがデフォルトでサポートしている主な型
   → P.211 の 表5.2
 - 指定可能な主な引数のアノテーション
   → P.211 の 表5.3
   → P.212 の 表5.4
   ※　Spring 4.3から新たに @SessionAttribute と @RequestAttribute が追加   

 - 暗黙的な引数の解決
   - 引数の型がStringやIntegerといったシンプル型【14】の場合は、引数名に一致するリクエストパラメータの値を取
     得する
   - 引数の型がJavaBeansの場合は、JavaBeansのデフォルトの属性名に一致するオブジェクトをModelから取得する。
     該当するオブジェクトがModelに存在しない場合は、デフォルトコンストラクタを呼び出して新しいオブジェクトを
     生成する
 - 注意点
   - Servlet API、低レベルの Java APIなどは、メンテナンス性が低下するので極力使用しない。

★ Handleメソッドの戻り値
 - 指定可能な主な型
   → P.213 の 表5.5

★ リクエストマッピング
 - 複数の属性を指定した場合はそれぞれAND条件（絞り込み条件）として扱われます
 - 指定可能な属性
   → P.215 の 表5.8

★ リクエストパス
 - クラスレベルに指定するとベースパスとして扱われる
 - メソッドレベルに指定するとベースパスからの相対パスとして扱われる
 - 複数の属性値を指定した場合はOR条件として扱われます。

★ パスパターン
 - URIテンプレート形式のパスパターン ── 例：/accounts/{accountId}

★ HTTPメソッド使用
 - GETメソッド ── Webページの取得やファイルのダウンロードなどサーバーから何かしらの情報を取得する際に使用する
 - POSTメソッド ── 何かしらの情報をサーバーへ送信する際に使用する（検索条件はPOSTでなくGETを使用するのが一般的）
 - 属性値には複数のHTTPメソッドを指定することもでき、複数の属性値を指定した場合はOR条件として扱われます。

★ リクエストパラメータ使用
 - 属性値には複数のパラメータを指定することもでき、複数の属性値を指定した場合はAND条件
 - @RequestMapping(path = "create", params = "form")
   で指定した場合、"/accounts/create?form="というURLでアクセスするとformメソッドが実行される。POSTメソッ
  ドを使ってリクエストする場合はリクエストボディに"form"というパラメータが含まれていればよい
 - HTML(JSP)側の実装
   - リンク（<a>要素）の場合は、URL内のクエリ文字列にリクエストパラメータを指定
   - HTMLフォーム内のボタン（<button>要素や<input type="submit">要素など）の場合は、name属性にリクエストパラメータの名前を指定

★ リクエストヘッダーの使用
 - @RequestMapping(headers = "X-Migration=true") の場合
    →　X-Migrationヘッダーの値にtrueを指定してアクセスするとpostMigrationAccountメソッドが実行される
 - 属性値には複数のヘッダーを指定することもでき、複数の属性値を指定した場合はAND条件

★ Content-Typeヘッダーの使用
 - @RequestMapping(consumes = "application/json") 
   →　リクエストボディにJSON（メディアタイプがapplication/json）を指定してアクセスするとpostAccountメソッドが実行される
 - 属性値には複数のメディアタイプを指定することもでき、複数の属性値を指定した場合はOR条件

★ Acceptヘッダーの使用
---------------------------------------
 @RequestMapping(path = "create", produces = "application/json") ❶
 @ResponseBody
 public Account postAccount(@Validated @RequestBody Account account) {
---------------------------------------
の場合、
、レスポンスボディとしてJSON（メディアタイプがapplication/json）を受け取ることができるクライアントがアクセスするとpostAccountメソッドが実行される。

★ リクエストデータの取得
   → P.222 の 図5.6 が分かりやすい

 - 取得時の注意
   @PathVariable、@RequestParam、@RequestHeader、@CookieValueのvalue（name）属性を省略する場合、
   -gオプション（デバッグ情報を出力するモード）またはJava SE 8から追加された-parametersオプション（メ
   ソッドまたはパラメータにリフレクション用のメタデータを生成するモード）のどちらかのコンパイルオプショ
   ンを有効にする必要があります。


★ バインディング処理のカスタマイズ（WebDataBinder）
 - まず 
  --------------------------------------------
  @InitBinder
  public void initBinder(WebDataBinder binder) {
  --------------------------------------------
 - で、
  --------------------------------------------
  @InitBinder
  public void initBinder(WebDataBinder binder) {
    binder.addCustomFormatter(new DateFormatter("yyyyMMdd"));
  }
 --------------------------------------------
 

★ アノテーションを使用したフォーマットの指定
 --------------------------------------------
@DateTimeFormat(pattern = "yyyyMMdd")
 private Date dateOfBirth;
 --------------------------------------------

//==========================================================================================================
// 5.6 フォームクラスの実装
//==========================================================================================================
★ フォームオブジェクトのスコープ
 - リクエストスコープ
   - 単にModelにオブジェクトを格納するだけ
   - 画面遷移する際にフォームデータを<input type="hidden">を使って引き回す必要がある
 - フラッシュスコープ
   - 画面遷移をリダイレクトで行う際でも、遷移先に値を渡すための値のスコープ。
   - 
 - セッションスコープ
 　- @SessionAttributes(types = echoForm.class)
 
★　シンプル型のコレクションとのバインディング
----------------------
<input type="checkbox" name="roles" value="1"> 利用者
<input type="checkbox" name="roles" value="2"> 承認者
<input type="checkbox" name="roles" value="3"> システム管理者
----------------------
の場合に、formで
List<String> roles;
となる。

★ ネストしたJavaBeansとのバインディング
 - サンプル作成

★ プロパティ値のリセット
 - リセット用のリクエストパラメータは、データバインディング用のリクエストパラメータの名前の先頭に「_」（アン
   ダースコア）を付けたもので、rolesという名前のプロパティに対するリセット用のリクエストパラメータは、_roles
   という名前になります。

//==========================================================================================================
// 5.7 入力チェック
//==========================================================================================================
★ 入力チェックの有効化
 - @Validated

★ 入力チェック結果の判定
 - hasErrors()

★ 未入力の扱い
 - @InitBinder

★ 入力チェックルールの指定
 - 必須チェック　@NotNull
 - 桁数チェック @Size(max = 50) // 50文字以内であること
 - 文字種チェック @Pattern(regexp = "[a-zA-Z0-9]*") // 英数字であること
 - 数値の妥当性チェック @NumberFormat
 - 数値の範囲チェック 
    -----------------------------------
    @Min(1)
    @Max(100) // 1から100であること
    private int quantity;
    -----------------------------------
    @Digits(integer = 2, fraction = 2) // -99.99から99.99であること
    private BigDecimal rate;
    -----------------------------------
 - 日時の妥当性チェック
    -----------------------------------
    @Past // 過去日時であること
    @DateTimeFormat(pattern = "yyyyMMdd")
    private Date dateOfBirth;
    -----------------------------------
 - 真偽値チェック
    -----------------------------------
    @AssertTrue // true(利用規約に同意済み)であること
    private boolean isAgreedTermsOfUse;
    -----------------------------------

★ ネストしたJavaBeansの入力チェック
    -----------------------------------
    @Valid // ネストしたJavaBeansもチェック対象となる
    private AccountForm account;
    -----------------------------------

★ 入力チェックルールの追加
 - 既成ルールを合成して作成する方法
    -----------------------------------
    @AlphaNumeric // @Patternではなく独自の制約アノテーションを利用
    private String couponCode;
    -----------------------------------

★ 入力チェックルールの切り替え
    -----------------------------------
    @Size.List({
      @Size(max = 0, groups = FreeAccount.class),
      @Size(min = 14, max = 16, groups = PayAccount.class)
    })
    -----------------------------------

★ エラー情報の表示
 - <form:form>および<form:input>などの要素を利用すると、自動でエラー値を表示してくれる仕組みになっています。
   そのため、開発者はエラー値を表示するために特別な実装を行なう必要ありません。

★ エラーメッセージの解決
 - エラーメッセージの定義方法
   - Springのデフォルトの実装では、まずMessageSourceからメッセージを取得し、MessageSourceからメッセージが取得
     できない場合はBean Validationの仕様で解決されたメッセージを使います




//==========================================================================================================
★ とりあえずメモ
 - Spring 4.0よりWebSocketの連携モジュールが提供されている
 - Spring 4.2からは、Spring MVCの仕組みを使用したSSE（Server-Sent Events）がサポート




//==========================================================================================================
// <END>
//==========================================================================================================
