//==========================================================================================================
// Spring徹底入門SpringFrameworkによるJavaアプリケーション開発.pdf
//==========================================================================================================
 - (CHAPTER 05) Webアプリケーションの開発(P.203 - 307)
しおり　：　P.301 ～ 5.13.4 Spring MVCの例外ハンドラの利用 ～
URL　:
http://localhost:8080/SpringWebApplication03/

★ 2017/08/11(金)に、SpringWebApplication03の勉強の為にSpringMVC02_01 から派生して作成
   - 

//==========================================================================================================
// 5.1 Webアプリケーションの種類 
//==========================================================================================================
★ Springには大きく分けて２種類の機能がある
 - 画面応答アプリケーション
 - データのみ応答するアプリケーション




//==========================================================================================================
// 5.2 アプリケーションの設定
//==========================================================================================================

//==========================================================================================================
// 5.3 @Controllerの実装
//==========================================================================================================
★ サーブレットコンテナの設定
 - ContextLoaderListener
   - @Configuration 付きのクラスを作成する

 - DispatcherServlet
   - はクライアントからのリクエストを受け付ける
   - @Configuration 付きのクラスを作成する
   - @EnableWebMvc
   - @ComponentScan("example.app") 

 - CharacterEncodingFilter
   - setCharacterEncoding("UTF-8");

★ 本格的なアプリケーションコンテキスト
 - MessageSource
   - メッセージ取得用
 - PropertySourcesPlaceholderConfigurer
   - プロパティ値（JVMのシステムプロパティ、環境変数、プロパティファイルに定義した値）をDIコンテナで管理し
     ているコンポーネントにインジェクションするためのコンポーネント

★ Controllerで実装する処理の全体像
 - メソッドシグネチャを参照してフロントコントローラが処理を行なう「宣言型」の処理
   - リクエストマッピング
   - リクエストデータの取得
   - 入力チェックの実行
 - Controllerクラスのメソッド内に処理を実装する「プログラミング型」の処理
   - 入力チェック結果のハンドリング
   - ビジネスロジックの呼び出し
   - 遷移先とのデータ連携
   - 遷移先の指定

★ Controllerクラスの作成
 - POJOで作成
 - POJOクラスに@Controllerを指定することで、以下の効果を得られます。
   - コンポーネントスキャン機能を使用してDIコンテナにBean登録可能
   - リクエストをハンドリングするメソッド（以降、Handlerメソッドと呼ぶ）が定義されているクラスとして認識
 - value属性を省略した場合はSpringが定めた命名規約に則ったBean IDが適用
   - クラス名「WelcomeController」→ 「welcomeController」
 - コンポーネントスキャン機能を使ってDIコンテナに登録

★ Handleメソッドの引数
 - Spring MVCがデフォルトでサポートしている主な型
   → P.211 の 表5.2
 - 指定可能な主な引数のアノテーション
   → P.211 の 表5.3
   → P.212 の 表5.4
   ※　Spring 4.3から新たに @SessionAttribute と @RequestAttribute が追加   

 - 暗黙的な引数の解決
   - 引数の型がStringやIntegerといったシンプル型【14】の場合は、引数名に一致するリクエストパラメータの値を取
     得する
   - 引数の型がJavaBeansの場合は、JavaBeansのデフォルトの属性名に一致するオブジェクトをModelから取得する。
     該当するオブジェクトがModelに存在しない場合は、デフォルトコンストラクタを呼び出して新しいオブジェクトを
     生成する
 - 注意点
   - Servlet API、低レベルの Java APIなどは、メンテナンス性が低下するので極力使用しない。

★ Handleメソッドの戻り値
 - 指定可能な主な型
   → P.213 の 表5.5

//==========================================================================================================
// 5.4 リクエストマッピング
//==========================================================================================================
★ リクエストマッピング
 - 複数の属性を指定した場合はそれぞれAND条件（絞り込み条件）として扱われます
 - 指定可能な属性
   → P.215 の 表5.8

★ リクエストパス
 - クラスレベルに指定するとベースパスとして扱われる
 - メソッドレベルに指定するとベースパスからの相対パスとして扱われる
 - 複数の属性値を指定した場合はOR条件として扱われます。

★ パスパターン
 - URIテンプレート形式のパスパターン ── 例：/accounts/{accountId}

★ HTTPメソッド使用
 - GETメソッド ── Webページの取得やファイルのダウンロードなどサーバーから何かしらの情報を取得する際に使用する
 - POSTメソッド ── 何かしらの情報をサーバーへ送信する際に使用する（検索条件はPOSTでなくGETを使用するのが一般的）
 - 属性値には複数のHTTPメソッドを指定することもでき、複数の属性値を指定した場合はOR条件として扱われます。

★ リクエストパラメータ使用
 - 属性値には複数のパラメータを指定することもでき、複数の属性値を指定した場合はAND条件
 - @RequestMapping(path = "create", params = "form")
   で指定した場合、"/accounts/create?form="というURLでアクセスするとformメソッドが実行される。POSTメソッ
  ドを使ってリクエストする場合はリクエストボディに"form"というパラメータが含まれていればよい
 - HTML(JSP)側の実装
   - リンク（<a>要素）の場合は、URL内のクエリ文字列にリクエストパラメータを指定
   - HTMLフォーム内のボタン（<button>要素や<input type="submit">要素など）の場合は、name属性にリクエストパラメータの名前を指定

★ リクエストヘッダーの使用
 - @RequestMapping(headers = "X-Migration=true") の場合
    →　X-Migrationヘッダーの値にtrueを指定してアクセスするとpostMigrationAccountメソッドが実行される
 - 属性値には複数のヘッダーを指定することもでき、複数の属性値を指定した場合はAND条件

★ Content-Typeヘッダーの使用
 - @RequestMapping(consumes = "application/json") 
   →　リクエストボディにJSON（メディアタイプがapplication/json）を指定してアクセスするとpostAccountメソッドが実行される
 - 属性値には複数のメディアタイプを指定することもでき、複数の属性値を指定した場合はOR条件

★ Acceptヘッダーの使用
---------------------------------------
 @RequestMapping(path = "create", produces = "application/json") ❶
 @ResponseBody
 public Account postAccount(@Validated @RequestBody Account account) {
---------------------------------------
の場合、
、レスポンスボディとしてJSON（メディアタイプがapplication/json）を受け取ることができるクライアントがアクセスするとpostAccountメソッドが実行される。





//==========================================================================================================
// 5.5 リクエストデータの取得 
//==========================================================================================================

★ リクエストデータの取得
   → P.222 の 図5.6 が分かりやすい

 - 取得時の注意
   @PathVariable、@RequestParam、@RequestHeader、@CookieValueのvalue（name）属性を省略する場合、
   -gオプション（デバッグ情報を出力するモード）またはJava SE 8から追加された-parametersオプション（メ
   ソッドまたはパラメータにリフレクション用のメタデータを生成するモード）のどちらかのコンパイルオプショ
   ンを有効にする必要があります。


★ バインディング処理のカスタマイズ（WebDataBinder）
 - まず 
  --------------------------------------------
  @InitBinder
  public void initBinder(WebDataBinder binder) {
  --------------------------------------------
 - で、
  --------------------------------------------
  @InitBinder
  public void initBinder(WebDataBinder binder) {
    binder.addCustomFormatter(new DateFormatter("yyyyMMdd"));
  }
 --------------------------------------------
 

★ アノテーションを使用したフォーマットの指定
 --------------------------------------------
@DateTimeFormat(pattern = "yyyyMMdd")
 private Date dateOfBirth;
 --------------------------------------------




//==========================================================================================================
// 5.6 フォームクラスの実装
//==========================================================================================================
★ フォームオブジェクトのスコープ
 - リクエストスコープ
   - 単にModelにオブジェクトを格納するだけ
   - 画面遷移する際にフォームデータを<input type="hidden">を使って引き回す必要がある
 - フラッシュスコープ
   - 画面遷移をリダイレクトで行う際でも、遷移先に値を渡すための値のスコープ。
   - 
 - セッションスコープ
 　- @SessionAttributes(types = echoForm.class)
 
★　シンプル型のコレクションとのバインディング
----------------------
<input type="checkbox" name="roles" value="1"> 利用者
<input type="checkbox" name="roles" value="2"> 承認者
<input type="checkbox" name="roles" value="3"> システム管理者
----------------------
の場合に、formで
List<String> roles;
となる。

★ ネストしたJavaBeansとのバインディング
 - サンプル作成

★ プロパティ値のリセット
 - リセット用のリクエストパラメータは、データバインディング用のリクエストパラメータの名前の先頭に「_」（アン
   ダースコア）を付けたもので、rolesという名前のプロパティに対するリセット用のリクエストパラメータは、_roles
   という名前になります。

//==========================================================================================================
// 5.7 入力チェック
//==========================================================================================================
★ 入力チェックの有効化
 - @Validated

★ 入力チェック結果の判定
 - hasErrors()

★ 未入力の扱い
 - @InitBinder

★ 入力チェックルールの指定
 - 必須チェック　@NotNull
 - 桁数チェック @Size(max = 50) // 50文字以内であること
 - 文字種チェック @Pattern(regexp = "[a-zA-Z0-9]*") // 英数字であること
 - 数値の妥当性チェック @NumberFormat
 - 数値の範囲チェック 
    -----------------------------------
    @Min(1)
    @Max(100) // 1から100であること
    private int quantity;
    -----------------------------------
    @Digits(integer = 2, fraction = 2) // -99.99から99.99であること
    private BigDecimal rate;
    -----------------------------------
 - 日時の妥当性チェック
    -----------------------------------
    @Past // 過去日時であること
    @DateTimeFormat(pattern = "yyyyMMdd")
    private Date dateOfBirth;
    -----------------------------------
 - 真偽値チェック
    -----------------------------------
    @AssertTrue // true(利用規約に同意済み)であること
    private boolean isAgreedTermsOfUse;
    -----------------------------------

★ ネストしたJavaBeansの入力チェック
    -----------------------------------
    @Valid // ネストしたJavaBeansもチェック対象となる
    private AccountForm account;
    -----------------------------------

★ 入力チェックルールの追加
 - 既成ルールを合成して作成する方法
    -----------------------------------
    @AlphaNumeric // @Patternではなく独自の制約アノテーションを利用
    private String couponCode;
    -----------------------------------

★ 入力チェックルールの切り替え
    -----------------------------------
    @Size.List({
      @Size(max = 0, groups = FreeAccount.class),
      @Size(min = 14, max = 16, groups = PayAccount.class)
    })
    -----------------------------------

★ エラー情報の表示
 - <form:form>および<form:input>などの要素を利用すると、自動でエラー値を表示してくれる仕組みになっています。
   そのため、開発者はエラー値を表示するために特別な実装を行なう必要ありません。

★ エラーメッセージの解決
 - エラーメッセージの定義方法
   - Springのデフォルトの実装では、まずMessageSourceからメッセージを取得し、MessageSourceからメッセージが取得
     できない場合はBean Validationの仕様で解決されたメッセージを使います


//==========================================================================================================
// 5.8 画面遷移
//==========================================================================================================
※ ソースコードで説明


//==========================================================================================================
// 5.9 Viewの解決
//==========================================================================================================
★ Bean定義
-----------------------------------------------------------------------
@Override
public void configureViewResolvers(ViewResolverRegistry registry) {
	// この記述で、prefixプロパティに"/WEB-INF/"、suffixプロパティに".jsp"が設定される
	registry.jsp();
	// 格納先の指定は以下のようになる
	registry.jsp().prefix("/WEB-INF/views/");
	
}
-----------------------------------------------------------------------

//==========================================================================================================
// 5.10 JSPの実装
//==========================================================================================================
※ 課題では、JSPは使わないので一旦後回しにする。

★ EL（Expression Language）
 - <span id="message">${message}</span>
 - エスケープ処理は行なわないため、上記の実装だとクロスサイトスクリプティングが発生する可能性があります。
 - 


//==========================================================================================================
// 5.11 SpringのHTMLフォーム用タグライブラリの利用
//==========================================================================================================
※ 課題では、JSPは使わないので一旦後回しにする。


//==========================================================================================================
// 5.12 Springの汎用タグライブラリの利用
//==========================================================================================================
※ 課題では、JSPは使わないので一旦後回しにする。


//==========================================================================================================
// 5.13 例外ハンドリング
//==========================================================================================================
★ 例外の種類
 - システム例外
 - リクエスト不正を通知する例外
 - アプリケーション例外

★ 例外の発生個所とハンドリング方法
 - Servlet	Filter
   → サーブレットコンテナのエラーページ機能（web.xmlの<error-page>要素）を使用してエラー処理を実装

 - DispatcherServlet
   → SpringMVCが提供する例外ハンドリングの仕組み（HandlerExceptionResolver）を使用してエラー処理を実装

 - アプリケーション（Controller、Service、Repository など）
   → プログラム内でのtry～catchやSpring MVCが提供する例外ハンドリングの仕組み（HandlerExceptionResolver）を使用してエラー処理を実装

 - View（JSP など）
   → サーブレットコンテナのエラーページ機能（web.xmlの<error-page>要素）を使用してエラー処理を実装

★ サーブレットコンテナのエラーページ機能の利用
 - エラーページで参照可能なエラー情報
   - レスポンスのステータスコード
   - 例外オブジェクトの型
   - 例外のメッセージ
   - 例外オブジェクト
   - 例外が発生したリクエストのURI
   - 例外が発生したリクエストに割り当てられたサーブレットの名前
 - 型階層の扱い
 - 原因例外の扱い
   - ServletException（またはServletExceptionのサブクラス）やjava.lang.Exceptionに対するエラーページの定義を行なった場合は、原因例外による遷移先の指定はできません。

★ Spring MVCの例外ハンドラの利用
 - HandlerExceptionResolver
   (1) ExceptionHandlerExceptionResolver
   (2) ResponseStatusExceptionResolver
   (3) DefaultHandlerExceptionResolver
       → (P.303)表 5.64　デフォルトで適用される HandlerExceptionResolver の実装クラス


//==========================================================================================================
★ とりあえずメモ

★プロジェクト作成
 - 通常作成
   - studyprj02\springFrameworkInfo\samples\springFrameworkThoroughIntroduction\sample-programs\15-appendix\a1
 - プロジェクトのcoreを直接編集
   - https://kadoppe.com/archives/2011/03/eclipse-project-facets-dynamic-web-module-version-downgrade.html
 - サーバに反映
   - STSを再起動
   - サーバのクリアとprofile実行



1. The superclass "javax.servlet.http.HttpServlet" was not found on the Java Build Path
　プロジェクトが作成された時点でApacheのライブラリがうまく追加されなかったみたいので、プロジェクトを右クリックし -> Properties -> Java Build Path -> Add Library -> Server Runtime -> Apache Tomcat -> Finish
をすれば解決できた。

//==========================================================================================================
// <END>
//==========================================================================================================
